## JS에서의 객체 정의 방식
```jsx
const person = {
    name : "김일",
    age : 20
};
```
이상의 형태가 python 에서는 dictionary 라는 표현을 쓰고, java 에서는 또 map 이라고 씁니다.

# Generic(제네릭)
## 정의
클래스나 메서드가 다룰 데이터 타입을 미리 명시하여 재사용성과 유연성을 높이는 기술

### 타입 매개변수(Type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 '대신하여 사용하는 매개변수'
- 일반적으로 알파벳 대문자 하나로 표기함
  - T(Type) : 일반적으로 클래스 타입을 나타낼 때 사용
  - E(Element) : 컬렉션의 요소를 나타낼 때 사용
  - K(Key) : Map의 Key를 나타낼 때 사용
  - V(Value) : Map의 Value 또는 제네릭 타입의 리턴 값으로 사용
### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할 수 있어 코드의 재사용성을 높이고 중복을 줄임

    - 예를 들어 method overloading 개념이 있을 경우, Person 객체를 참조하여 bmi 를 계산한다고 가정하겠습니다.

```java
package org.example;

import lombok.*;

@Builder
@Data
public class Person {
    private String name;
    private double height;
    private double weight;
}

public static void calcBmi(Person person) {
    String result = "";
    String name = person.getName();
    double weight = person.getWeight();
    double height = person.getHeight() * 0.01;
    double Bmi = weight / (height * height);
    if (Bmi >= 35) {
        result = "3단계 비만";
    } else if (Bmi > 34.9) {
        result = "2단계 비만";
    } else if (Bmi > 29.9) {
        result = "1단계 비만";
    } else if (Bmi > 24.9) {
        result = "비만 전단계";
    } else if (Bmi > 22.9) {
        result = "정상";
    } else if (Bmi > 18.5) {
        result = "저체중";
    }
    System.out.printf("\n%s 님의 BMI 지수는 %.2f으로 %s 입니다.", name, Bmi, result);
}

```
이상과 같이 쓸 수 있겠습니다. 그렇다면, 만약에 Student 클래스가 Person 클래스를 상속받았다고 가정할 때, Student 클래스 용으로 또
method overloading을 해야하는가와 같은 문제가 있습니다. 그리고 Student의 상속을 받는 MiddleSchoolStedent 라든지 HighSchoolStudent
가 있으면 더 골치가 아파짐
* 참고 : 사실은 업캐스팅이 이루어지기 때문에 별 문제 없음

### 타입 안정성(Type Safrty)
- 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고, 명시적인 형변환을 줄임

# Java 제네릭 와일드카드(Generic Wildcard)
## 제네릭
- 클래스, 인터페이스, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법으로 다양한 타입에 재사용이 가능
```java
public class Box<t> {
    private T value;
    public void setValue(T value) {
        this.value = value;
    }
    public T getValue() {
        return value;
    }
}
```
이상의 코드와 같은 방식으로 작성했을 때 value의 자료형을 고정시키지 않고 사용이 가능.
value에 String / Integer / Double ... etc 등으로 사용 가능.
즉 Java 자체의 자료형(class) 뿐만 아니라 개발자가 정의한 것도 집어넣을 수 있다는 점에서 재사용성이 높다고 할 수 있음.

## 와일드카드
- 이상의 제네릭 타입을 사용할 때 구체적인 타입을 명시하지 않고 범용적으로 처리하고 싶을 때 사용함. `?` 기호를 사용함.

```java
import java.util.ArrayList;

public static void main(String[] args) {
  List<?> exampleList = new ArrayList<String>();
}
```
`<?>`은 어떤 타입이든 가능하다는 의미입니다.

### 종류
1. 모든 타입 허용
   - 읽기 전용. 어떤 타입이든지 받아야만 할 때
2. T 또는 T의 서브 타입(자식 클래스)
   - 읽기 전용. 제한된 타입에서 읽을 때
3. T 또는 T의 슈퍼 타입(부모 클래스)
   - 쓰기 전용. 제한된 타입으로 넣을 때

# Collection
- 여러 객체를 모아놓은 것들만 의미함 -> 배열과는 좀 차이가 있습니다.
- 다만 Java에서의 List는 Python 에서의 List와도 차이가 있습니다.

## 종류
1. List : 순서가 있는 데이터의 집합으로, 중복된 요소를 허락함.
    - ArrayList : 배열 기반의 리스트, 요소 접근 속도가 빠름.
    - LinkedList : 연결 리스트, 삽입 / 삭제 속도가 빠름.
2. Set : 중복을 허용하지 않는(List 와의 차이 # 1) 데이터들의 집합
    - HashSet : 해시 테이블 기반의 집합, element의 순서를 보장하지 않음.(List 와의 차이 # 2)
    - TreeSet : 이진(binary) 검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨.
3. Map : Key / Value의 쌍으로 이루어진 데이터들의 집합
    - HashMap : 해시 테이블 기반의 맵, 키의 순서를 보장 X
    - TreeMap : 이진 검색 트리 기반의 맵, 키가 정렬된 상태로 유지
* Java 상에서의 키(Key)-값(Value) 상을 지칭하는 용어 : Entry
* Js(JavaScript) 상에서 객체의 키-값 상을 지칭하는 용어 : Property
* 근데 문제는 Python 에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes - Java 상에서의 field
List는 순서가 있고 중복을 허용하는 반면, Set의 경우 순서는 없고 중복은 허용하지 않기 때문에 List -> Set / Set -> List 로의 형변환이 중요합니다. 예를 들어 List로 전체 설문을 받고, Set을 통해 중복을 제거하여 후보군만 남기는 등의 형태로 많이 사용됩니다. 또한 Set 으로 중복을 제거한 후에 다시 List로 돌려서 .get(인덱스넘버)로 조회도 할 수 있습니다. Set은 순서가 없어서 ... 그래서 Set은 집합과 매우 유사하지만 집합은 숫자로만 이루어져있지만 Set은 다양한 자료형을 기준으로 만들어질 수 있다는 차이가 있습니다.

    