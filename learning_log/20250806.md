# 향상된 for문(Enhanced For Loop)
일반 for 문과의 차이점 : 일반 for 문의 경우 인덱스 넘버(주소지)를 명확하게 알고 있어야 일일이 element의 숫자를 
세는 것이 번거롭기 때문에 배열명.length와 같은 형식으로 일종의 field 참조를 통해 int 값을 추출하여 대입해야만 했습니다.
그런데 잘 생각해보면 for (int i = 0 ; ...) 부분에서 int i는 for문 내부에서만 사용이 가능합니다.
이를 응용하여 배열 내의 element에 for문 내부에서만 사용하는 변수에 대입하는 방식으로 index 넘버(주소지)의 사용없이 적용할 수 있는
for 문 반복문이 있는데. 이를 향상된 for 문이라고 합니다.

제약 : 읽기만 되고, 쓰기가 안됩니다(1부터 100까지 추출하는건 되는데 집어넣는건 제한적으로 된다.)
```java
public static void main(String[] args) {
    for (자료형 변수명 : 반복가능객체(배열)) {
        반복실행문
    }
}
```

# cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록을 전부 import 해옴
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        
        int randomNum;
        double[] scores = new double[25];
        String[] student = new String[25];
        // 막 내부 로직들 엄청나게 써놓고 있다고 가정하다가 저 밑에서 갑자기 students가 튀어나왔다고 가정해보겠습니다.
        if (randomNum < 0)
        {
            // 이런 형식으로 실행문을 써야 합니다. 라는 식으로 회사에서 정하는 경우가 있음
        }
    }
}
```

## 배열의 출력
엄밀하게 말하자면 저희는 배열을 출력한게 아니라 이때까지 배열 내부의 요소들을 출력했습니다.
System.out.println(arr01); 과 같은 출력문을 작성했을 때 주소값만 나온다는 것을 알 수 있습니다. 
근데 요소의 값을 조정하거나, 더하거나와 같은 추가적은 가공을 하기 위해서 for 반복문을 사용해왔는데, 
굳이 변형이 없고 배열 자체를 확인하고 싶을 때마다 main에 반복문 작성하든지 method를 정의하든지 하는 일은 번거로운 일이 됩니다.
Arrays 클래스를 정의하고, "정적" 메서드인 .toString(배열명)을 사용하면 배열 전체를 출력할 수 있습니다.
여기서 우리는 클래스명.메서드명()이라는 점에 주목할 필요가 있습니다. scanner.nextLine()과는 다릅니다. 
그리고 toString()이라는 메서드도 곧 사용하게 됩니다. 여기서 중요한 점은 동일한 method 명이라고 하더라도 
어떤 클래스에 종속되어있는가에 따라 다른 결과값을 지닐 수 있다는 점입니다.

## 다차원 배열 중에서 2차원 배열
다차원 배열은 2차원 이상의 배열을 의미하지만, 2차원 배열 이상을 다루는 경우는 극히 드물기 때문에 2차원 배열을 기본으로 생각.
2차원 배열 선언 시 , 열의 크기는 지정하지 않아도 되지만, 행의 크기는 항상 지정해야 함.
```java
int[][] arr01 = new int[크기][크기]; // 선언 방식 1 
int[][] arr02 = new int[크기][]; // 선언 방식 2 
int[][] arr03 = {{1,2},{3,4},{5,6}}; // 선언 방식 및 초기화
```
    1열 2열(column)
      ↓  ↓
    { 1, 2 }, → 1 행(row)    가로줄을 '행'
    { 3, 4 }, → 2 행
    { 5, 6 }  → 3 행

# 상속
객체지향프로그래밍(OOP)의 핵심 개념 중 하나로, 기존 클래스((부모)(슈퍼) 클래스)의 field와 method를 재사용하여 새로운 클래스((자식)(서브) 클래스)를 만드는 것을 의미함.

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가 재사용 가능

    - 동물(Animal) : 클래스가 있고, 이를 상속 받는 개(Dog) / 고양이(Cat) 클래스가 있다고 가정했을 때, 동물의 공통적인 
    field(이름 / 나이 등)와 행위(걷기 / 먹기 등)을 부모 클래스에 정의, 개와 고양이는 각각 고유한 특성(짖기 / 우다다다)을 추가할 수 있음
  
- 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고 또 Cat 에다가 이름 / 나이 / 걷기 / 먹기 / 우다다다
를 정의하는 등의 공통된 부분을 정의하는 일 없이 특정 field 및 메서드만 정의하면 됨. -> 중복된 코드를 줄일 수 있다.

## 상속의 특징
1. 단일 상속 -  Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어 상속 구조가 간단하고 명확함.
2. Super 키워드 - 클래스의 생성자 및 setter 에서 학습한 this와 유사한 개념으로 부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함
3. method override - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의`할 수 있음. 이를 통해 자식 클래스는 부모 클래스의 기본 동작을 자신만의 방식으로 변경 가능
- 예시
      - Animal 클래스의 걷기를 Dog가 상속 받고, 네 발로 걷기로 _재정의_, Human 클래스가 걷기를 상속 받고 두 발로 걷기로 _재정의_ 가 가능합니다.
4. final 키워드 - 클래스의 final이 붙으면 상속 불가
    - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용화 - 동일한 코드를 반복적으로 작성할 필요 x
2. 유지 보수의 용이성 - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에 위계 파악 후 수정하면 됩니다.
3. 객체 간 관계 표현 - IS-A 관계를 명확히 나타냄
    - IS-A : "개"는 "동물"의 일종이다. 와 같은 예시로, IS-A는 is a kind of의 축약어
    - 그래서 우리가 미리 만들어둔 Animal / Tiger / Human의 클래스를 예로 들었을 때, Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

# Super 키워드
1. super(); - 부모 생성자를 호출
2. super.메서드명(); - 부모 클래스의 메서드를 호출

## 상속관계시 생성자
부모-자식의 상속관계가 성립되어 있을 때,
부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면
자식 클래스에서 완벽한 기본 생성자를 만드는 것이 불가능합니다. 자식 클래스의 객체 생성 시 필수적으로 "부모 클래스의 생성자를 호출"하기 때문입니다.

예시 :
    A a = new b();


